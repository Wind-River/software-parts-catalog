# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Query {
  # test_archive is not implemented and should probably be removed
  test_archive: Archive!
  # archive returns the archive matching the given sha256 exactly, or matching the given name exactly if sha256 was not given or found
  archive(sha256: String, name: String): Archive
  # find_archive searches the database for archives with names like the given query
  find_archive(query: String!, method: String): [ArchiveDistance!]!
  # part returns the part matching the first matching not nil identifying info 
  part(id: UUID, file_verification_code: String, sha256: String, sha1: String, name: String): Part
  # archives list archives pointing to the part identified by part_id or verification code
  archives(id: UUID, vcode: String): [Archive!]!
  partlist(id: Int64, name: String): PartList
  partlist_parts(id: Int64!): [Part]!
  partlists(parent_id: Int64!): [PartList]!
  # file_count returns the number of files owned by the given part and its sub-parts
  file_count(id: UUID, vcode: String): Int64!
  # comprised returns the list of parts that are comprised by the given part
  # see Part.comprised if you are looking for what comprises a given part
  comprised(id: UUID): [Part!]!
  # profile returns a list of both document types, with an optional title field
  profile(id: UUID, key: String): [Document!]
}

scalar Upload

input PartInput {
  id: UUID!
  type: String
  name: String
  version: String
  family_name: String
  file_verification_code: String
  license: String
  license_rationale: String
  license_notice: String
  automation_license: String
  automation_license_rationale: String
  comprised: UUID
}

type Mutation {
  addPartList(name: String!, parent_id: Int64): PartList!
  deletePartList(id: Int64!): PartList!
  deletePartFromList(list_id: Int64!, part_id: UUID!): PartList!
  # Upload an archive to be processed into a part
  uploadArchive(file: Upload!, name: String): UploadedArchive!
  # Updates the part associated with the given archive
  # An error will be returned if the associated part hasn't been created yet
  updateArchive(sha256: String!, license: String, licenseRationale: String, familyString: String): Archive
  updatePartList(id: Int64!, name: String, parts: [UUID]): PartList!
  # Update the given part with non-nil and non-zero fields
  updatePart(partInput: PartInput): Part
  # Create a part alias
  createAlias(id: UUID!, alias: String!): UUID!
  # Attach a document to a part
  # If title is not given, it is a part_has_document, else it is a part_documents entry
  attachDocument(id: UUID!, key: String!, title: String, document: JSON!): Boolean!
  # Adds a sub-part to a part at a path
  partHasPart(parent: UUID!, child: UUID!, path: String!): Boolean!
  # Adds a fil eto a part, potentially at a path
  partHasFile(id: UUID!, file_sha256: String!, path: String): Boolean!
}

scalar Int64
scalar Time
scalar UUID
scalar JSON

type Archive {
  sha256: String!
  Size: Int64
  part_id: UUID
  part: Part
  md5: String
  sha1: String
  name: String
  insert_date: Time!
}

type ArchiveDistance {
  distance: Int64!
  archive: Archive!
}

type SubPart {
  path: String!
  part: Part!
}

type Part {
  id: UUID!
  type: String!
  name: String
  version: String
  family_name: String
  file_verification_code: String
  size: Int64
  license: String
  license_rationale: JSON
  license_notice: String
  automation_license: String
  automation_license_rationale: JSON
  comprised: UUID
  aliases: [String!]
  profiles: [Profile!]
  sub_parts: [SubPart!]
}

type PartList {
  id: Int64!
  name: String!
  parent_id: Int64
}

type License {
  name: String!
}

type UploadedArchive {
  extracted: Boolean!
  archive: Archive
}

type Profile {
  key: String!
  documents: [Document!]!
}

type Document {
  title: String
  document: JSON!
}